"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOrder = void 0;
const Order_1 = require("../../shared/entity/Order");
const dataexception_1 = require("../../shared/exceptions/dataexception");
const Conection_1 = require("../Conection");
class DOrder {
    constructor() { }
    static getInstance() {
        if (!DOrder.instancia) {
            DOrder.instancia = new DOrder();
        }
        return DOrder.instancia;
    }
    async addOrder(dtorder) {
        try {
            var randomenumber = Math.floor(Math.random() * (9999999999 + 1));
            dtorder.id = randomenumber;
            var now = new Date();
            dtorder.date = now;
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.insertOne(dtorder);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Order could not be added" + e.message);
        }
    }
    async deleteOrder(dtorder) {
        try {
            let query = { _id: dtorder.id };
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.deleteOne(dtorder);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Order could not be deleted" + e.message);
        }
    }
    async updatestateOrder(dtorder) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            let query = { _id: dtorder.id };
            var newvalues = { $set: { _state: dtorder.state } };
            const colorder = cn.db("ECommerce").collection("Order");
            const result = await colorder.updateOne(query, newvalues);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Order could not be updated" + e.message);
        }
    }
    //***************************************************** */
    async getOrder(id) {
        let orderobj = null;
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const getorder = await collection.findOne({ _id: id });
            if (getorder == null) {
                return null;
            }
            orderobj = new Order_1.Order(getorder._id, getorder._date, getorder._state, getorder._total, getorder._client, getorder._listOrderDetails);
            return orderobj;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Order could not be searched");
        }
    }
    async listpendingOrders() {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.find({ _state: 'Pending' }).toArray();
            let array = [];
            for (var order of result) {
                var orderobj = new Order_1.Order(order._id, order._date, order._state, order._total, order._client, order._listOrderDetails);
                array.push(orderobj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Orders could not be listed" + e.message);
        }
    }
    async listdeliveredOrders() {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.find({ _state: 'Delivered' }).toArray();
            let array = [];
            for (var order of result) {
                var orderobj = new Order_1.Order(order._id, order._date, order._state, order._total, order._client, order._listOrderDetails);
                array.push(orderobj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Orders could not be listed" + e.message);
        }
    }
    async listClientOrders(identitycard) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.find({ "_client._identitycard": identitycard }).toArray();
            let array = [];
            for (var order of result) {
                var orderobj = new Order_1.Order(order._id, order._date, order._state, order._total, order._client, order._listOrderDetails);
                array.push(orderobj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Orders could not be listed" + e.message);
        }
    }
    async getOrders() {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.find({}).toArray();
            let array = [];
            for (var order of result) {
                var orderobj = new Order_1.Order(order._id, order._date, order._state, order._total, order._client, order._listOrderDetails);
                array.push(orderobj);
            }
            cn.close();
            return array;
        }
        catch (e) {
            throw new dataexception_1.DataException("Orders could not be listed" + e.message);
        }
    }
    async listOrdersbyDate(date1, date2) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Order");
            const result = await collection.find({ $and: [{ _date: { '$gte': date1 } }, { _date: { '$lte': date2 } }, { _state: 'Delivered' }] }).toArray();
            let array = [];
            for (var order of result) {
                var orderobj = new Order_1.Order(order._id, order._date, order._state, order._total, order._client, order._listOrderDetails);
                array.push(orderobj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Orders could not be listed" + e.message);
        }
    }
}
exports.DOrder = DOrder;
//# sourceMappingURL=DOrder.js.map