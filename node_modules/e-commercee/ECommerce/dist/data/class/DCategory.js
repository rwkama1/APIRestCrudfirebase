"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCategory = void 0;
const Category_1 = require("../../shared/entity/Category");
const dataexception_1 = require("../../shared/exceptions/dataexception");
const Conection_1 = require("../Conection");
class DCategory {
    constructor() { }
    static getInstance() {
        if (!DCategory.instancia) {
            DCategory.instancia = new DCategory();
        }
        return DCategory.instancia;
    }
    async addCategory(dtcat) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Category");
            const result = await collection.insertOne(dtcat);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Category could not be added" + e.message);
        }
    }
    async updateCategory(dtcat) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            let query = { _name: dtcat.name };
            var newvalues = { $set: { _description: dtcat.description } };
            const coladvert = cn.db("ECommerce").collection("Category");
            const result = await coladvert.updateOne(query, newvalues);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Category could not be updated" + e.message);
        }
    }
    async deleteCategory(dtcat) {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            let query = { _name: dtcat.name };
            const colcat = cn.db("ECommerce").collection("Category");
            const result = await colcat.deleteOne(query);
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Category could not be deleted" + e.message);
        }
    }
    async getCategory(name) {
        let categoryobj = null;
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Category");
            const category = await collection.findOne({ _name: name });
            if (category == null) {
                return null;
            }
            categoryobj = new Category_1.Category(category._name, category._description);
            return categoryobj;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Category could not be searched");
        }
    }
    async getCategorysByNameLetter(expression) {
        try {
            var cn = await Conection_1.Conexion.uri().connect();
            var query = { _name: { $regex: expression } };
            const collection = cn.db("ECommerce").collection("Category");
            const result = await collection.find(query).toArray();
            let array = [];
            for (var p of result) {
                var obj = new Category_1.Category(p._name, p._description);
                array.push(obj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Category could not be listed" + e.message);
        }
    }
    async getCategories() {
        try {
            let cn = await Conection_1.Conexion.uri().connect();
            const collection = cn.db("ECommerce").collection("Category");
            const result = await collection.find({}).toArray();
            let array = [];
            for (var p of result) {
                var obj = new Category_1.Category(p._name, p._description);
                array.push(obj);
            }
            return array;
            cn.close();
        }
        catch (e) {
            throw new dataexception_1.DataException("Categories could not be listed" + e.message);
        }
    }
}
exports.DCategory = DCategory;
//# sourceMappingURL=DCategory.js.map